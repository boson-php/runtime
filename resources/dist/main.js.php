var D=r=>{throw TypeError(r)};var I=(r,t,e)=>t.has(r)||D("Cannot "+e);var n=(r,t,e)=>(I(r,t,"read from private field"),e?e.call(r):t.get(r)),s=(r,t,e)=>t.has(r)?D("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(r):t.set(r,e),d=(r,t,e,o)=>(I(r,t,"write to private field"),o?o.call(r,e):t.set(r,e),e),i=(r,t,e)=>(I(r,t,"access private method"),e);var E,B;class H{constructor(){s(this,E)}generate(t=16){return Array.from(this.generateByteArray(t)).map(i(this,E,B)).join("")}}E=new WeakSet,B=function(t){return t.toString(16).padStart(2,"0")};var w,u,A;const g=class g extends H{constructor(e){super();s(this,w);d(this,w,e||(function(){throw new Error("Could not load client cryptographic library")})())}static createFromGlobals(){return new g(i(this,u,A).call(this))}static isSupported(){return!!i(this,u,A).call(this)}generateByteArray(e){return n(this,w).getRandomValues(new Uint8Array(e))}};w=new WeakMap,u=new WeakSet,A=function(){return window.crypto||window.msCrypto||window.msrCrypto||void 0},s(g,u);let f=g;class N{static createFromGlobals(){if(f.isSupported())return f.createFromGlobals();throw new Error("Can not select suitable ID generator")}}var c,h,b,a,P,L;class T{constructor(t,e){s(this,a);s(this,c,{});s(this,h);s(this,b);d(this,b,t),d(this,h,e)}resolve(t,e){var o;e instanceof Promise?e.then(l=>this.resolve(t,l)).catch(l=>this.reject(t,l)):(o=i(this,a,P).call(this,t))==null||o.resolve(e)}reject(t,e){var o;(o=i(this,a,P).call(this,t))==null||o.reject(e)}call(t,e){const o=n(this,h).generate(),l=i(this,a,L).call(this,o);return n(this,b).send(JSON.stringify({id:o,method:t,params:e})),l}}c=new WeakMap,h=new WeakMap,b=new WeakMap,a=new WeakSet,P=function(t){const e=n(this,c)[t]??null;try{return e}finally{e!==null&&delete n(this,c)[t]}},L=function(t){return new Promise((e,o)=>n(this,c)[t]={resolve:e,reject:o})};var p;class U{constructor(t){s(this,p);d(this,p,t??(function(){throw new Error("Unsupported transport")})())}send(t){n(this,p).call(this,t)}}p=new WeakMap;var m,S;const x=class x extends U{static createFromGlobals(){return new x(i(this,m,S).call(this))}static isSupported(){return!!i(this,m,S).call(this)}};m=new WeakSet,S=function(){var t,e;return(e=(t=window.chrome)==null?void 0:t.webview)==null?void 0:e.postMessage},s(x,m);let F=x;var y,v;const C=class C extends U{static createFromGlobals(){return new C(i(this,y,v).call(this))}static isSupported(){return!!i(this,y,v).call(this)}};y=new WeakSet,v=function(){var t,e;return(e=(t=window.saucer)==null?void 0:t.internal)==null?void 0:e.send_message},s(C,y);let G=C;class q{static createFromGlobals(){if(F.isSupported())return F.createFromGlobals();if(G.isSupported())return G.createFromGlobals();throw new Error("Can not select suitable IPC transport")}}window.boson||(window.boson={});var R;try{(R=window.boson).io||(R.io=q.createFromGlobals())}catch(r){console.error("Failed to initialize IPC subsystem",r)}var j;try{(j=window.boson).ids||(j.ids=N.createFromGlobals())}catch(r){console.error("Failed to initialize ID generator subsystem",r)}var z;try{if(!window.boson.io||!window.boson.ids)throw new Error("Could not initialize RPC: Requires IPC and ID generator subsystems");(z=window.boson).rpc||(z.rpc=new T(window.boson.io,window.boson.ids))}catch(r){console.error("Failed to initialize RPC subsystem",r)}
